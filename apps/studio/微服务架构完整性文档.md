# @sker/studio 微服务架构完整性文档

## 📋 架构修复概述 (2025-09-29)

### 🚨 识别的问题
队列服务存在不当的回退机制，违反了微服务架构的基本原则：
- `QueueService` 实现了 `fallbackMode` 允许绕过消息队列
- `NodeService` 在队列不可用时回退到直接AI调用
- 基础设施故障被静默降级处理，用户无法感知真实的系统状态

### ✅ 实施的解决方案

#### 1. QueueService 架构强化
**移除的不当机制**:
```typescript
// ❌ 已移除的回退机制
private fallbackMode = false
private async handleDirectAICall() { ... }
```

**新增的严格依赖检查**:
```typescript
// ✅ 严格的服务依赖验证
private async ensureQueueServiceAvailable(): Promise<void> {
  if (!this.isQueueHealthy) {
    throw new Error(
      '消息队列服务不可用。请确保以下服务正常运行:\n' +
      '1. WebSocket连接已建立\n' +
      '2. 后端消息队列服务(RabbitMQ)正常\n' +
      '3. 网络连接稳定'
    )
  }
}
```

#### 2. NodeService 集成模式优化
**修改前的问题代码**:
```typescript
// ❌ 不当的回退逻辑
if (queueService.isAvailable()) {
  return await queueService.submitAITask(request)
} else {
  return await aiService.directCall(request) // 违反架构原则
}
```

**修改后的严格模式**:
```typescript
// ✅ 严格的队列依赖
private async generateContentWithAI(request: AIGenerateRequest): Promise<AIGenerateResponse> {
  try {
    const taskId = await queueService.submitAITask(request, {
      priority: 5,
      timeout: 60000,
      retryCount: 2
    })
    return await this.waitForTaskCompletion(taskId)
  } catch (error) {
    throw new Error(
      'AI内容生成失败: ' + errorMessage +
      '\n\n这通常是由于以下原因:\n' +
      '1. 消息队列服务不可用\n' +
      '2. WebSocket连接中断\n' +
      '3. 后端AI处理服务异常'
    )
  }
}
```

#### 3. 错误处理透明化
**增强的用户反馈机制**:
- 明确区分应用逻辑错误和基础设施故障
- 提供具体的故障排除指导
- 避免静默降级，确保用户了解系统真实状态

## 🏗️ 微服务架构层级

### 4层服务架构
```
Frontend (Canvas UI)
       ↓
Gateway Service (API Router)
       ↓
Broker Service (Message Queue)
       ↓
Engine Service (AI Processing)
       ↓
Store Service (Data Persistence)
```

### 服务间通信协议
1. **Frontend ↔ Gateway**: HTTP/WebSocket
2. **Gateway ↔ Broker**: Message Queue (RabbitMQ)
3. **Broker ↔ Engine**: Internal Queue Protocol
4. **Engine ↔ Store**: Database Connection

### 依赖关系约束
- **严格向下依赖**: 上层服务只能依赖下层服务
- **无跨层调用**: 禁止跨层直接调用 (如 Frontend 直接调用 Engine)
- **无回退机制**: 依赖服务不可用时必须报错，不允许绕过

## 🔍 健康检查机制

### 服务可用性监控
```typescript
interface ServiceHealth {
  websocket: 'connected' | 'disconnected' | 'connecting'
  messageQueue: 'healthy' | 'unhealthy' | 'unknown'
  aiEngine: 'available' | 'busy' | 'error'
  dataStore: 'connected' | 'disconnected'
}
```

### 健康检查流程
1. **启动时检查**: 应用启动时验证所有依赖服务
2. **实时监控**: WebSocket连接状态实时更新
3. **心跳机制**: 定期发送健康检查消息
4. **故障恢复**: 服务恢复后自动重连和状态同步

## 📊 监控和诊断

### 错误分类
1. **基础设施错误**: 消息队列、数据库、网络连接故障
2. **业务逻辑错误**: AI处理失败、数据验证错误
3. **用户交互错误**: 输入验证、权限检查失败

### 诊断信息提供
```typescript
// 示例：详细的错误上下文
{
  error: "消息队列服务不可用",
  context: {
    websocketStatus: "disconnected",
    lastHeartbeat: "2025-09-29T10:30:00Z",
    queueHealth: "unknown",
    suggestedActions: [
      "检查网络连接",
      "确认后端服务状态",
      "联系系统管理员"
    ]
  }
}
```

## 🛡️ 架构完整性保证

### 代码审查要点
1. **禁止回退机制**: 所有服务调用必须处理依赖不可用的情况
2. **错误传播**: 底层错误必须向上传播，不允许静默处理
3. **依赖注入**: 使用依赖注入确保服务间的正确耦合关系

### 测试策略
1. **单元测试**: 验证各服务的错误处理逻辑
2. **集成测试**: 测试服务间的依赖关系和故障处理
3. **故障注入**: 模拟依赖服务故障，验证错误处理

## 📋 实施清单

### ✅ 已完成
- [x] 移除 QueueService 中的 fallbackMode 机制
- [x] 实现严格的服务健康检查
- [x] 修改 NodeService 移除 AI 服务回退
- [x] 增强错误消息和用户指导
- [x] 更新架构文档和设计说明

### 🔄 后续优化
- [ ] 实施完整的服务监控仪表板
- [ ] 添加自动故障恢复机制
- [ ] 建立服务性能基准测试
- [ ] 实现分布式链路追踪

## 🎯 架构原则总结

1. **透明性**: 用户必须了解系统真实状态
2. **完整性**: 微服务架构不允许跨层或绕过调用
3. **可靠性**: 故障时明确报告，不允许静默降级
4. **可维护性**: 清晰的服务边界和依赖关系
5. **可观测性**: 完整的监控和诊断能力

这些修改确保了 @sker/studio 严格遵循微服务架构原则，提供了可靠、透明、可维护的AI协作平台。