# 🚀 扩展式AI协作画布 - MVP开发计划 V2.0

## 项目概述

**世界之初，一切虚无**

用户面对空白的无限画布，双击任意位置，输入一句话，AI生成内容，一个组件诞生。连线、运行、扩展，从虚无到万物，构建属于你的AI协作宇宙。

这是一个基于"文字生成文字"的极简AI协作平台，让思维在无限画布上自由流淌。

**V2.0设计理念**：在保持极简创造体验的基础上，通过组件语义化、信息层次管理和智能版本控制，打造真正适合大规模思维协作的平台。

## 核心交互：从无到有的创造

### 宇宙创世循环

```
∅ 虚无画布 (道)
    ↓ 双击任意位置
🌱 第一个组件诞生 (道生一)
    ↓ 拖拽连线扩展
🌿 第二个组件诞生 (一生二)
    ↓ 右键创建空组件
⭕ 空组件等待融合 (二生三的准备)
    ↓ 连接到组件1和组件2
🔗 建立多输入关系
    ↓ 点击空组件的生成按钮
💭 [输入提示词] "融合以上两个分析，制定综合方案"
    ↓ AI处理多输入上下文
✨ 融合组件诞生 (二生三)
    ↓ 继续创建空组件
🌐 连接所有有用节点 (三生万物的准备)
    ↓ 全局上下文聚合
🔮 [输入提示词] "基于所有分析，制定完整解决方案"
    ↓ AI处理全局上下文
🌌 万物组件诞生 (三生万物)
    ↓ 无限递归创造
♾️ 宇宙生态完成
```

### 极简创建体验

**步骤1: 双击创世**
```
用户看到: ∅ 空白无限画布
用户行为: 双击画布任意位置
系统响应: 弹出输入框 "在此输入你的想法..."
```

**步骤2: 输入种子**
```
用户输入: "我想做一个电商网站"
用户按下: Enter键
系统响应: AI生成第一个组件内容，自动生成组件标题
```

**步骤3: 连线扩展 (一生二)**
```
用户操作: 选中第一个组件，拖拽出连线到空白处
系统响应: 连线末端悬空，出现输入框
用户输入: "分析这个需求的技术架构"
用户确认: 按回车或点击确认
系统响应: AI基于 [前组件内容] + [用户提示词] 生成新组件
         新组件自动出现在连线末端，连线完成
         系统自动为新组件生成标题和设置重要性等级
```

**步骤4: 融合创造 (二生三)**
```
用户操作: 右键画布空白处，选择"创建空组件"
系统响应: 创建一个空白组件，等待内容生成
用户操作: 从组件1拖拽连线到空组件，从组件2也拖拽连线到空组件
系统响应: 空组件显示多个输入连接
用户操作: 点击空组件的▶️生成按钮
系统响应: 弹出输入框："如何处理这些输入内容？"
用户输入: "综合以上分析，制定产品MVP方案"
系统响应: AI基于 [组件1内容] + [组件2内容] + [用户提示词] 生成融合内容
         空组件填充内容，成为真正的融合组件
         自动分析并设置组件的重要性等级
```

**步骤5: 万物生成 (三生万物)**
```
用户操作: 右键画布空白处，再次创建空组件（万物节点）
系统响应: 创建新的空白组件，准备接收全局输入
用户操作: 从画布上所有有价值的组件拖拽连线到万物节点
         - 连接原始需求组件
         - 连接技术方案组件  
         - 连接MVP方案组件
         - 连接用户分析组件
         - 连接资源评估组件...
系统响应: 万物节点显示："输入: 5个" 或更多连接数
用户操作: 点击万物节点的▶️生成按钮
系统响应: 弹出输入框："基于所有输入，你希望生成什么？"
用户输入: "基于所有分析，制定完整的产品开发执行计划"
系统响应: AI基于 [全部组件内容聚合] + [用户提示词] 生成最终方案
         万物节点成为包含完整解决方案的终极组件
         
结果展示: 一个包含完整产品规划的超级组件，整合了所有前期分析
```

**步骤6: 内容优化升级 (万物重生)**
```
用户操作: 双击任意已生成内容的组件
系统响应: 弹出优化对话框，显示当前组件的内容预览
         同时显示变更原因输入框："请描述此次修改的原因"
用户输入优化指令: "增加更详细的技术实现细节"
用户输入变更原因: "需要更具体的技术指导"
用户选择变更类型: "确定性改进" (而非实验性尝试)
系统响应: AI基于 [当前组件内容] + [优化提示词] 重新生成内容
         组件内容更新，版本号递增
         记录完整的变更历史和原因
         保持原有连线关系不变
         
历史记录: 用户可查看版本历史，了解每次变更的原因和效果
回滚功能: 支持安全回滚到任意历史版本
```

### 组件设计

**智能内容组件 (已生成)**：
- 📝 **标题区域**：AI自动生成或用户自定义的组件标题
- ⭐ **重要性指示器**：1-5星等级，影响组件的视觉权重
- 🎯 **置信度显示**：AI生成内容的可信度评分 (0-100)
- 👤 **用户评分**：用户对内容质量的反馈评分 (1-5星)
- 🏷️ **语义标签**：自动识别的内容类型标签
- 🔗 **输出连接点**：可以拖拽连线到其他组件
- ✏️ **编辑模式**：支持人工修改内容
- 🔄 **双击优化**：双击组件可重新生成内容
- 📋 **版本信息**：显示当前版本和最近变更原因

**空组件 (待生成)**：
- ⭕ **空白区域**：等待AI生成内容
- 🔗 **输入连接点**：可以接收多个输入连线
- ▶️ **生成按钮**：点击后输入提示词，AI融合生成内容
- 📊 **状态指示器**：显示输入连接数量和生成状态

**优化组件 (重生中)**：
- 🔄 **处理状态**：显示"正在优化..."动画
- 📝 **变更对话框**：显示优化指令、变更原因、变更类型选择
- ↩️ **回滚选项**：提供回到上一个版本的选择
- 📈 **版本预览**：显示即将发生的变更内容

### 画布多层次展示系统

**概览模式 (Overview)**：
```
┌─────────────────────────────────────────────────────────────────┐
│ 🔍 概览模式 - 整体结构一目了然                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─⭐⭐⭐⭐⭐─┐    ┌─⭐⭐⭐⭐─┐    ┌─⭐⭐⭐─┐                      │
│  │需求分析     │───►│技术架构    │───►│MVP计划│                     │
│  │v3          │    │v2         │    │v1     │                     │
│  └────────────┘    └───────────┘    └───────┘                     │
│                                         │                        │
│  ┌─⭐⭐⭐─┐                             ▼                        │
│  │资源评估│                         ┌─⭐⭐⭐⭐⭐─┐                    │
│  │v1     │────────────────────────►│执行方案   │                    │
│  └───────┘                         │v1        │                    │
│                                     └──────────┘                    │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
- 只显示组件标题和重要性星级
- 连线关系清晰可见，便于理解思维流程
- 组件大小基于重要性等级，核心组件更突出

**预览模式 (Preview)**：
```
┌─────────────────────────────────────────────────────────────────┐
│ 👁️ 预览模式 - 结构与内容平衡展示                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─需求分析 ⭐⭐⭐⭐⭐─┐                                            │
│  │• 核心用户群体分析    │                                        │
│  │• 主要功能需求梳理    │───────┐                               │
│  │• 竞品分析和差异化... │       │                               │
│  │📊 置信度: 85%       │       ▼                               │
│  └─────────────────────┘   ┌─技术架构 ⭐⭐⭐⭐─┐                   │
│                           │• 前端: React + TS │                   │
│                           │• 后端: Node.js... │                   │
│  ┌─资源评估 ⭐⭐⭐─┐          │📊 置信度: 78%     │                   │
│  │• 开发成本: 15万      │          └─────────────────┘                   │
│  │• 时间周期: 3个月     │                  │                        │
│  │• 团队配置建议...     │                  ▼                        │
│  └─────────────────────┘             ┌─MVP计划─┐                   │
│                                      │...     │                   │
│                                      └────────┘                   │
└─────────────────────────────────────────────────────────────────┘
```
- 显示标题 + 前2-3行关键内容
- 保持连线关系可见
- 平衡结构感知和内容预览

**详细模式 (Detail)**：
```
┌─────────────────────────────────────────────────────────────────┐
│ 📋 详细模式 - 完整内容深度阅读                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─需求分析 ⭐⭐⭐⭐⭐ v3 "增加竞品分析" - 确定性改进──────────┐      │
│  │                                                           │      │
│  │ 📌 核心用户群体分析：                                     │      │
│  │ • 小企业主 (50-200人规模)                                │      │
│  │ • 痛点：缺乏专业的客户管理工具                           │      │
│  │ • 预算：月均 200-500元                                   │      │
│  │                                                           │      │
│  │ 📌 主要功能需求：                                         │      │
│  │ • 客户信息管理 (联系方式、购买历史、偏好)                │      │
│  │ • 销售流程跟踪 (线索-商机-成交)                          │      │
│  │ • 简单的数据分析 (销售趋势、客户价值)                    │      │
│  │                                                           │      │
│  │ 📌 竞品分析：                                             │      │
│  │ • Salesforce: 功能强大但价格高昂，小企业难以负担         │      │
│  │ • 小满CRM: 价格适中但功能相对简单                        │      │
│  │ • 差异化策略: 专注小企业场景，提供更简单易用的解决方案   │      │
│  │                                                           │      │
│  │ 📊 置信度: 85% | 👤 用户评分: ⭐⭐⭐⭐ | 🏷️ 市场分析       │      │
│  │ 📋 版本历史 | ✏️ 编辑内容                                │      │
│  └───────────────────────────────────────────────────────────┘      │
│                                   │                                │
│                                   ▼                                │
│  ┌─技术架构 ⭐⭐⭐⭐ v2 "调整数据库设计" - 实验性尝试─────────┐         │
│  │ [显示完整的技术架构内容...]                            │         │
│  └─────────────────────────────────────────────────────────┘         │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```
- 显示组件的完整内容
- 显示详细的版本信息和变更历史
- 适合深度阅读和内容编辑

### 画布演进示例

**阶段1: 虚无**
```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│                        ∅ 无限虚空                               │
│                                                                 │
│                    (双击任意位置开始创造)                        │
│                                                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**阶段2: 第一个组件诞生 (道生一)**  
```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│                   ┌─电商网站构想 ⭐⭐⭐⭐─┐                        │
│                   │AI生成标题              │                        │
│                   │                        │                        │
│                   │"我想做一个电商网站，主要│                        │
│                   │面向小企业，帮助他们...  │                        │
│                   │                        │                        │
│                   │📊 置信度: 78%          │                        │
│                   │🏷️ 项目构想              │                        │
│                   │📝[编辑] 🔄[优化]       │                        │
│                   └────────────────────────┘                        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**阶段3: 连线扩展 (一生二)**
```
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  ┌─电商网站构想 ⭐⭐⭐⭐─┐                                         │
│  │初始想法和目标       │                                         │
│  │📊 置信度: 78%       │─────────┐                              │
│  │🏷️ 项目构想          │         │                              │
│  └─────────────────────┘         ▼                              │
│                              ┌─需求分析 ⭐⭐⭐⭐⭐─┐                 │
│                              │AI深度分析用户需求│                 │
│                              │• 目标用户群体    │                 │
│                              │• 核心功能模块    │                 │
│                              │• 技术可行性...   │                 │
│                              │📊 置信度: 85%    │                 │
│                              │🏷️ 需求分析       │                 │
│                              └──────────────────┘                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**阶段4: 多方融合 (二生三)**
```
┌─────────────────────────────────────────────────────────────────┐
│  ┌─需求分析 ⭐⭐⭐⭐⭐─┐     ┌─技术方案 ⭐⭐⭐⭐─┐                      │
│  │用户和功能需求分析   │────┐│前后端技术选型    │                      │
│  │📊 置信度: 85%       │    ││📊 置信度: 80%     │                      │
│  │🏷️ 需求分析          │    │└──────────────────┘                      │
│  └─────────────────────┘    │                                        │
│                             │        ┌─市场分析 ⭐⭐⭐─┐                │
│                             │        │竞品和定价策略 │                │
│                             │        │📊 置信度: 72% │                │
│                             │        └───────────────┘                │
│                             │               │                        │
│                             └───────────────┼──────┐                 │
│                                             │      ▼                 │
│                                             │  ⭕ 空组件               │
│                                             │  等待融合               │
│                                             │  输入: 3个              │
│                                             │  ▶️[生成]               │
│                                             │                        │
│                                             ▼                        │
│                                         💭 用户输入                  │
│                                         "制定完整MVP方案"             │
│                                             ▼                        │
│                                     ✨ MVP方案 ⭐⭐⭐⭐⭐              │
│                                     融合三方分析的综合方案            │
│                                     📊 置信度: 88%                  │
│                                     🏷️ 产品方案                     │
└─────────────────────────────────────────────────────────────────┘
```

### 组件状态管理

**状态类型**：
- ⏸️ **待运行**：组件内容已准备，等待点击运行
- 🔄 **运行中**：AI正在处理，显示加载动画
- 🟢 **已完成**：AI处理完成，内容已更新
- 🔴 **运行错误**：处理失败，显示错误信息和重试选项
- ✏️ **编辑中**：用户正在手动编辑内容
- 🔄 **优化中**：AI正在根据优化提示词重新生成内容
- 📋 **已优化**：内容优化完成，版本号已更新

**状态流转**：
```
待运行 ──点击运行──→ 运行中 ──AI完成──→ 已完成
  ↑                              ↓
  └────── 用户编辑 ←──────────── 编辑中
                                 ↓ 双击优化
                              优化中 ──AI完成──→ 已优化
                                 ↓              ↓
                              运行错误 ←─────── 历史回滚
```

**版本管理流转**：
```
v1 (初始版本) → v2 (首次优化) → v3 (二次优化) → ...
     ↑              ↑              ↑
   [安全回滚]     [安全回滚]     [安全回滚]
```

## 技术架构设计

### 核心技术栈
```yaml
前端框架: React 18 + TypeScript
画布引擎: React Flow (替代Konva.js，更好的性能和现代化API)
状态管理: Zustand (轻量级状态管理)
动画库: Framer Motion
UI组件: Tailwind CSS + Headless UI
实时通信: Socket.io
构建工具: Vite

后端框架: Node.js + Express + TypeScript  
数据库: PostgreSQL + Redis
AI集成: OpenAI GPT-4 API
消息队列: RabbitMQ + amqplib
部署: Docker + Docker Compose
```

### 系统架构
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端画布应用   │◄──►│   后端API服务    │◄──►│   统一LLM服务    │
│ React + Flow    │    │ Express + WS    │    │ GPT-4 + 提示词  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       ▼                       ▼
    ┌─────────┐         ┌─────────┐  ┌─────────┐  ┌─────────┐
    │  浏览器  │         │PostgreSQL│  │ RabbitMQ│  │  Redis  │
    │ 本地存储 │         │ 项目数据 │  │ 2个队列 │  │   缓存  │
    └─────────┘         └─────────┘  └─────────┘  └─────────┘
```

### React Flow画布引擎优势

**为什么选择React Flow而非Konva.js**：
- ✅ **虚拟化渲染**：内置虚拟化，轻松处理1000+节点
- ✅ **现代化API**：TypeScript友好，hooks支持
- ✅ **内置组件**：MiniMap、Controls、Background等
- ✅ **性能优化**：自动处理大量节点的性能问题
- ✅ **社区活跃**：文档完善，持续更新

**React Flow实现示例**：
```typescript
import ReactFlow, { 
  Node, 
  Edge, 
  Controls, 
  MiniMap,
  Background,
  useNodesState,
  useEdgesState 
} from 'reactflow';

interface ComponentNodeData {
  title: string;
  content: string;
  importance_level: number;
  confidence_score: number;
  user_rating: number;
  semantic_type: string;
  version: number;
  display_mode: 'overview' | 'preview' | 'detail';
}

const AICanvas = () => {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [displayMode, setDisplayMode] = useState('preview');

  return (
    <div className="ai-canvas-container h-screen">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={customNodeTypes}
        fitView
        minZoom={0.1}
        maxZoom={4}
      >
        <Controls />
        <MiniMap 
          nodeColor={(node) => getNodeColorByImportance(node.data.importance_level)}
          maskColor="rgb(240, 240, 240, 0.6)"
        />
        <Background variant="dots" gap={12} size={1} />
      </ReactFlow>
      
      <DisplayModeController 
        mode={displayMode}
        onChange={setDisplayMode}
      />
      <ComponentFilter />
      <SearchBox />
    </div>
  );
};
```

## RabbitMQ消息架构设计

### Agent消息处理机制

**简化的RabbitMQ架构**：
```yaml
消息队列拓扑:
  Exchange: llm.direct (Direct类型)
  
  队列设计:
    - llm.process.queue          # 统一LLM处理队列
    - result.notify.queue        # 结果通知队列

  消息格式:
    LLM处理消息:
      component_id: string      # 组件唯一ID
      context: string           # 收集的完整上下文内容
      user_prompt: string       # 用户的处理指令
      metadata: object          # 组件元信息 (V2.0新增)
```

### 消息流转设计

**连线创建组件的消息流 (一生二)**：
```
1. 用户拖拽连线到空白处
   → 前端显示悬空连线和输入框
   → 用户输入提示词并确认
   → 前端收集上下文:
     - 源组件的完整内容和元信息
     - 用户输入的提示词
   → 发送WebSocket消息到后端

2. 后端处理连线创建请求
   → 构造完整上下文: [源组件内容] + [用户提示词]
   → 发布到 llm.process.queue  
   → LLM Service基于上下文生成新组件内容
   → 同时生成组件标题、语义类型、重要性等级
   → 发布结果到 result.notify.queue
   → 前端创建新组件，显示AI生成的内容和元信息，完成连线

3. 后续交互
   → 用户可以编辑新组件的标题和内容
   → 可以调整重要性等级和用户评分
   → 可以从新组件继续拖拽连线扩展
   → 无限递归创造
```

**多输入融合组件的消息流 (二生三)**：
```
1. 用户右键画布空白处创建空组件
   → 前端创建空白组件，状态为"等待连接"
   → 显示空组件占位符和连接点

2. 用户连接多个输入组件
   → 从组件1拖拽连线到空组件
   → 从组件2拖拽连线到空组件  
   → 空组件显示输入连接数: "输入: 2个"

3. 用户点击空组件的生成按钮
   → 弹出输入框："如何处理这些输入内容？"
   → 用户输入融合提示词

4. 后端处理多输入融合请求
   → 收集所有输入组件的内容和元信息 (按order_index排序)
   → 构造融合上下文: 
     [组件1: 标题+内容+重要性] + "\n\n---\n\n" + [组件2: 标题+内容+重要性] + "\n\n---\n\n" + [用户提示词]
   → 发布到 llm.process.queue
   → LLM Service基于多输入上下文生成融合内容
   → 同时分析生成组件的重要性等级和置信度
   → 发布结果到 result.notify.queue
   → 空组件填充生成内容，状态变为"已生成"

5. 融合组件完成
   → 空组件变为真正的内容组件
   → 自动设置合适的重要性等级
   → 可以继续作为输入连接到其他组件
   → 支持继续编辑和扩展
```

**内容优化重生的消息流 (万物重生)**：
```
1. 用户双击已完成的组件
   → 前端检测到双击事件
   → 弹出优化对话框，包含:
     - 当前组件内容预览
     - 优化指令输入框："如何优化这个内容？"
     - 变更原因输入框："请描述此次修改的原因"
     - 变更类型选择：实验性尝试 | 确定性改进 | 细节完善

2. 用户输入优化指令和变更信息
   → 输入优化提示词："增加更详细的技术实现细节"
   → 输入变更原因："需要更具体的技术指导"
   → 选择变更类型："确定性改进"
   → 前端发送优化请求到后端

3. 后端处理内容优化请求
   → 收集当前组件的完整内容和元信息
   → 构造优化上下文: 
     "当前内容:\n" + [组件当前标题和内容] + "\n\n优化要求:\n" + [用户优化提示词]
   → 发布到 llm.process.queue (标记为优化类型)
   → LLM Service基于当前内容和优化要求生成新版本
   → 同时更新置信度评分
   → 发布结果到 result.notify.queue

4. 组件内容更新和版本管理
   → 保存当前版本到历史记录，包含:
     - 原始内容和元信息
     - 变更原因和变更类型
     - 变更前后的置信度对比
   → 更新组件内容为AI优化后的版本
   → 版本号递增 (v1 → v2)
   → 保持所有连线关系不变
   → 如果该组件连接到其他组件，优化后的内容会自动传递

5. 持续优化能力
   → 用户可以继续双击进行多轮优化
   → 支持版本回滚到任意历史版本
   → 版本历史显示每次变更的原因和效果
   → 优化不影响画布布局和连线关系
   → 下游组件可以基于优化后的内容继续工作
```

### 统一LLM服务架构

**增强的LLM处理服务**：
```typescript
// 统一LLM处理服务 (V2.0增强版)
class LLMProcessingService {
  private connection: amqp.Connection;
  private channel: amqp.Channel;
  
  async initialize(): Promise<void> {
    this.connection = await amqp.connect(RABBITMQ_URL);
    this.channel = await this.connection.createChannel();
    
    await this.channel.assertExchange('llm.direct', 'direct');
    await this.channel.assertQueue('llm.process.queue');
    await this.channel.assertQueue('result.notify.queue');
    
    this.channel.consume('llm.process.queue', this.handleLLMMessage.bind(this));
  }
  
  private async handleLLMMessage(msg: amqp.ConsumeMessage): Promise<void> {
    try {
      const data = JSON.parse(msg.content.toString()) as {
        component_id: string;
        context: string;
        user_prompt: string;
        metadata?: any;
        type?: 'create' | 'optimize' | 'fusion';
      };
      
      const result = await this.processWithLLM(data);
      
      // V2.0: 增强结果包含组件元信息
      const enhancedResult = {
        component_id: data.component_id,
        content: result.content,
        title: result.title,
        semantic_type: result.semantic_type,
        importance_level: result.importance_level,
        confidence_score: result.confidence_score,
        timestamp: Date.now()
      };
      
      // 发布处理结果
      await this.channel.sendToQueue(
        'result.notify.queue',
        Buffer.from(JSON.stringify(enhancedResult))
      );
      
      this.channel.ack(msg);
    } catch (error) {
      console.error('LLM处理错误:', error);
      // 发送错误状态
      await this.channel.sendToQueue(
        'result.notify.queue',
        Buffer.from(JSON.stringify({
          component_id: data.component_id,
          error: error.message,
          timestamp: Date.now()
        }))
      );
      this.channel.nack(msg, false, false);
    }
  }
  
  private async processWithLLM(data: any): Promise<any> {
    // V2.0: 增强的提示词，包含元信息生成
    const enhancedPrompt = this.buildEnhancedPrompt(data);
    
    // 调用OpenAI API进行处理
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        { 
          role: "system", 
          content: "你是一个智能内容分析助手。除了生成内容，还需要分析内容的语义类型、重要性等级(1-5)和置信度(0-100)。请以JSON格式返回结果。" 
        },
        { role: "user", content: enhancedPrompt }
      ],
      temperature: 0.7
    });
    
    return this.parseEnhancedResponse(response.choices[0].message.content);
  }
  
  private buildEnhancedPrompt(data: any): string {
    if (data.type === 'optimize') {
      return `
请优化以下内容：

当前内容:
${data.context}

优化要求:
${data.user_prompt}

请返回JSON格式：
{
  "content": "优化后的内容",
  "title": "组件标题(如果需要更新)",
  "semantic_type": "内容的语义类型",
  "importance_level": 数字1-5,
  "confidence_score": 数字0-100
}
      `;
    } else {
      return `
基于以下上下文生成内容：

${data.context}

用户指令：
${data.user_prompt}

请返回JSON格式：
{
  "content": "生成的内容",
  "title": "为此组件生成合适的标题",
  "semantic_type": "内容的语义类型(如：需求分析、技术方案、项目计划等)",
  "importance_level": 数字1-5,
  "confidence_score": 数字0-100
}
      `;
    }
  }
  
  private parseEnhancedResponse(response: string): any {
    try {
      return JSON.parse(response);
    } catch (error) {
      // 如果解析失败，提供默认值
      return {
        content: response,
        title: "AI生成内容",
        semantic_type: "general",
        importance_level: 3,
        confidence_score: 75
      };
    }
  }
  
  // 多输入上下文收集逻辑 (V2.0增强)
  private async collectMultiInputContext(componentId: string): Promise<string> {
    const inputComponents = await this.getInputComponents(componentId);
    
    // V2.0: 包含组件元信息的上下文
    const contextParts = inputComponents
      .sort((a, b) => a.order_index - b.order_index)
      .map(comp => {
        return `=== ${comp.title} (重要性: ${comp.importance_level}/5, 置信度: ${comp.confidence_score}%) ===\n${comp.content}`;
      })
      .filter(content => content?.trim())
      .join('\n\n---\n\n');
      
    return contextParts;
  }
  
  // 内容优化处理逻辑 (V2.0增强)
  private async processOptimization(data: any): Promise<any> {
    const optimizationPrompt = `
当前组件信息:
标题: ${data.current_title}
内容: ${data.current_content}
当前重要性: ${data.current_importance}/5
当前置信度: ${data.current_confidence}%

优化要求:
${data.user_prompt}

变更原因:
${data.change_reason}

变更类型:
${data.change_type}

请基于以上信息优化内容，并返回JSON格式结果，包含优化后的内容和更新的元信息。
    `;
    
    const response = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        { 
          role: "system", 
          content: "你是一个内容优化专家。根据用户要求优化内容，同时合理调整重要性等级和置信度。" 
        },
        { role: "user", content: optimizationPrompt }
      ],
      temperature: 0.7
    });
    
    return this.parseEnhancedResponse(response.choices[0].message.content);
  }
}
```

## 数据模型设计

### 项目表 (projects)
```sql
CREATE TABLE projects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title VARCHAR(255) NOT NULL DEFAULT 'Untitled Project',
  canvas_data JSONB NOT NULL DEFAULT '{}',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

### 增强的组件表 (components)
```sql
CREATE TABLE components (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  
  -- 基础信息
  title VARCHAR(255) NOT NULL DEFAULT '',
  content TEXT,
  position JSONB NOT NULL DEFAULT '{"x": 0, "y": 0}',
  status VARCHAR(20) DEFAULT 'pending',
  
  -- V2.0: 语义标识字段
  semantic_type VARCHAR(50) DEFAULT '',          -- 语义类型：需求分析、技术方案、项目计划等
  importance_level INTEGER DEFAULT 3 CHECK (importance_level >= 1 AND importance_level <= 5),
  confidence_score INTEGER DEFAULT 50 CHECK (confidence_score >= 0 AND confidence_score <= 100),
  user_rating INTEGER DEFAULT 0 CHECK (user_rating >= 0 AND user_rating <= 5),
  tags TEXT[] DEFAULT '{}',                      -- 用户自定义标签
  
  -- 版本管理
  version INTEGER DEFAULT 1,
  
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- 为新字段添加索引
CREATE INDEX idx_components_importance ON components(importance_level);
CREATE INDEX idx_components_semantic_type ON components(semantic_type);
CREATE INDEX idx_components_user_rating ON components(user_rating);
CREATE INDEX idx_components_status ON components(status);
```

### 连线关系表 (connections)
```sql
CREATE TABLE connections (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  source_component_id UUID REFERENCES components(id) ON DELETE CASCADE,
  target_component_id UUID REFERENCES components(id) ON DELETE CASCADE,
  order_index INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT NOW(),
  
  UNIQUE(project_id, source_component_id, target_component_id)
);

CREATE INDEX idx_connections_target ON connections(target_component_id, order_index);
CREATE INDEX idx_connections_source ON connections(source_component_id);
CREATE INDEX idx_connections_project ON connections(project_id);
```

### 语义化版本历史表 (component_versions)
```sql
CREATE TABLE component_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  component_id UUID REFERENCES components(id) ON DELETE CASCADE,
  version_number INTEGER NOT NULL,
  
  -- 版本内容
  title VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  semantic_type VARCHAR(50),
  importance_level INTEGER,
  confidence_score INTEGER,
  
  -- V2.0: 语义化版本管理字段
  change_reason TEXT NOT NULL,                   -- 用户输入的变更原因
  change_event TEXT,                            -- 触发变更的事件描述
  change_type VARCHAR(20) DEFAULT 'refinement'  -- 'experimental' | 'confirmed' | 'refinement'
    CHECK (change_type IN ('experimental', 'confirmed', 'refinement')),
  
  -- 变更前后对比数据
  original_data JSONB,                          -- 变更前的完整组件数据
  confidence_before INTEGER,                    -- 变更前的置信度
  confidence_after INTEGER,                     -- 变更后的置信度
  
  created_at TIMESTAMP DEFAULT NOW(),
  UNIQUE(component_id, version_number)
);

CREATE INDEX idx_component_versions_component ON component_versions(component_id, version_number DESC);
CREATE INDEX idx_component_versions_change_type ON component_versions(change_type);
CREATE INDEX idx_component_versions_created ON component_versions(created_at DESC);
```

### AI处理记录表 (ai_logs)
```sql  
CREATE TABLE ai_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  component_id UUID REFERENCES components(id) ON DELETE CASCADE,
  input_context TEXT NOT NULL,
  output_result JSONB,                          -- V2.0: 包含内容和元信息的完整结果
  processing_type VARCHAR(20) DEFAULT 'generate',
  status VARCHAR(20) DEFAULT 'processing',
  processing_time_ms INTEGER,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_ai_logs_component ON ai_logs(component_id, created_at DESC);
CREATE INDEX idx_ai_logs_status ON ai_logs(status);
CREATE INDEX idx_ai_logs_type ON ai_logs(processing_type);
```

## API设计

### 组件管理API

```typescript
// 组件创建
POST /api/components
{
  "project_id": "uuid",
  "title"?: string,
  "content"?: string,
  "position": { "x": number, "y": number },
  "semantic_type"?: string,
  "importance_level"?: number
}

// 组件更新
PUT /api/components/:id
{
  "title"?: string,
  "content"?: string,
  "importance_level"?: number,
  "user_rating"?: number,
  "tags"?: string[]
}

// 组件优化
POST /api/components/:id/optimize
{
  "optimization_prompt": string,
  "change_reason": string,
  "change_type": "experimental" | "confirmed" | "refinement"
}

// 版本管理
GET /api/components/:id/versions
POST /api/components/:id/rollback
{
  "target_version": number
}

// 组件搜索和筛选
GET /api/components/search?q=keyword&project_id=uuid
GET /api/components/filter?importance_min=3&semantic_type=需求分析&project_id=uuid
```

### 画布状态API

```typescript
// 保存画布状态
POST /api/projects/:id/canvas-state
{
  "display_mode": "overview" | "preview" | "detail",
  "filter_settings": object,
  "view_position": { "x": number, "y": number, "zoom": number }
}

// 获取画布状态
GET /api/projects/:id/canvas-state
```

## 前端组件设计

### 智能组件 (SmartComponent)

```typescript
interface SmartComponentProps {
  id: string;
  data: {
    title: string;
    content: string;
    importance_level: number;
    confidence_score: number;
    user_rating: number;
    semantic_type: string;
    version: number;
    status: ComponentStatus;
  };
  displayMode: 'overview' | 'preview' | 'detail';
  onUpdate: (updates: Partial<ComponentData>) => void;
  onOptimize: (prompt: string, reason: string, type: string) => void;
}

const SmartComponent: React.FC<SmartComponentProps> = ({ 
  id, 
  data, 
  displayMode, 
  onUpdate, 
  onOptimize 
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [showOptimizeDialog, setShowOptimizeDialog] = useState(false);

  return (
    <div className={`smart-component ${getImportanceClass(data.importance_level)}`}>
      {/* 组件头部 */}
      <ComponentHeader
        title={data.title}
        importance={data.importance_level}
        confidence={data.confidence_score}
        userRating={data.user_rating}
        semanticType={data.semantic_type}
        version={data.version}
        onTitleEdit={(newTitle) => onUpdate({ title: newTitle })}
        onImportanceChange={(level) => onUpdate({ importance_level: level })}
        onRatingChange={(rating) => onUpdate({ user_rating: rating })}
      />
      
      {/* 组件内容 */}
      <ComponentContent
        content={data.content}
        displayMode={displayMode}
        isEditing={isEditing}
        onContentEdit={(newContent) => onUpdate({ content: newContent })}
        onDoubleClick={() => setShowOptimizeDialog(true)}
      />
      
      {/* 组件脚部 */}
      <ComponentFooter
        status={data.status}
        onEdit={() => setIsEditing(true)}
        onOptimize={() => setShowOptimizeDialog(true)}
      />
      
      {/* 优化对话框 */}
      {showOptimizeDialog && (
        <OptimizeDialog
          currentContent={data.content}
          onOptimize={onOptimize}
          onClose={() => setShowOptimizeDialog(false)}
        />
      )}
    </div>
  );
};
```

### 画布控制器 (CanvasController)

```typescript
const CanvasController: React.FC = () => {
  const [displayMode, setDisplayMode] = useState<DisplayMode>('preview');
  const [filterSettings, setFilterSettings] = useState<FilterSettings>({});
  const [searchQuery, setSearchQuery] = useState('');

  return (
    <div className="canvas-controller">
      {/* 显示模式切换 */}
      <DisplayModeToggle
        mode={displayMode}
        onChange={setDisplayMode}
      />
      
      {/* 搜索框 */}
      <SearchBox
        query={searchQuery}
        onChange={setSearchQuery}
        placeholder="搜索组件标题或内容..."
      />
      
      {/* 筛选控制器 */}
      <FilterController
        settings={filterSettings}
        onChange={setFilterSettings}
      />
      
      {/* 画布统计 */}
      <CanvasStats
        totalComponents={stats.total}
        highImportanceCount={stats.highImportance}
        averageConfidence={stats.averageConfidence}
      />
    </div>
  );
};
```

### 版本历史组件 (VersionHistory)

```typescript
const VersionHistory: React.FC<{ componentId: string }> = ({ componentId }) => {
  const [versions, setVersions] = useState<ComponentVersion[]>([]);
  const [showDiff, setShowDiff] = useState<{ from: number; to: number } | null>(null);

  return (
    <div className="version-history">
      <h3>版本历史</h3>
      
      <div className="version-timeline">
        {versions.map((version) => (
          <div key={version.version_number} className="version-item">
            <div className="version-header">
              <span className="version-number">v{version.version_number}</span>
              <span className="change-type">{version.change_type}</span>
              <span className="timestamp">{formatDate(version.created_at)}</span>
            </div>
            
            <div className="change-reason">
              📝 {version.change_reason}
            </div>
            
            {version.change_event && (
              <div className="change-event">
                🔄 {version.change_event}
              </div>
            )}
            
            <div className="confidence-change">
              📊 置信度: {version.confidence_before}% → {version.confidence_after}%
            </div>
            
            <div className="version-actions">
              <button onClick={() => showVersionDiff(version)}>
                查看差异
              </button>
              <button onClick={() => rollbackToVersion(version.version_number)}>
                回滚到此版本
              </button>
            </div>
          </div>
        ))}
      </div>
      
      {showDiff && (
        <DiffViewer
          fromVersion={showDiff.from}
          toVersion={showDiff.to}
          onClose={() => setShowDiff(null)}
        />
      )}
    </div>
  );
};
```

## 📅 4周开发里程碑

### Week 1: 基础框架搭建 (基础画布 + 智能组件系统)

**Day 1-2: 项目初始化与架构搭建**
- [ ] 前后端项目脚手架搭建 (React + TypeScript + Node.js)
- [ ] 开发环境配置 (Docker + 热重载 + 代码规范)
- [ ] 数据库设计实现 (PostgreSQL表结构创建)
- [ ] RabbitMQ容器搭建和基础配置
- [ ] Redis缓存配置和连接
- [ ] 基础CI/CD流水线设置

**Day 3-4: React Flow画布引擎搭建**
- [ ] React Flow基础配置和集成
- [ ] 自定义节点类型设计 (SmartComponent)
- [ ] 画布交互功能：拖拽、缩放、平移
- [ ] MiniMap和Controls组件集成
- [ ] 画布坐标系统和边界处理
- [ ] 响应式画布适配

**Day 5-7: 智能组件系统开发**
- [ ] 组件元信息UI设计：标题、重要性、置信度显示
- [ ] 三种显示模式实现：概览/预览/详细
- [ ] 基于重要性的视觉层次设计
- [ ] 组件状态管理：待运行/运行中/已完成等
- [ ] 双击创建组件交互
- [ ] 组件编辑功能实现

**Week 1 验收标准**:
- ✅ React Flow画布正常运行，交互流畅
- ✅ 可以双击空白处创建第一个组件
- ✅ 组件显示标题、重要性、置信度等元信息
- ✅ 三种显示模式切换正常
- ✅ 基础的组件编辑功能工作正常

### Week 2: AI处理机制 + 连线扩展系统

**Day 8-9: LLM服务集成**
- [ ] RabbitMQ消息队列配置 (llm.process.queue, result.notify.queue)
- [ ] OpenAI API集成和配置
- [ ] 增强的LLM处理服务实现
- [ ] 消息格式设计：包含组件元信息
- [ ] WebSocket实时通信设置
- [ ] AI生成结果的解析和验证

**Day 10-11: 连线创建机制 (一生二)**
- [ ] 拖拽连线到空白处的交互
- [ ] 悬空连线状态和输入框显示
- [ ] 上下文收集机制：源组件内容+用户提示词
- [ ] AI处理连线创建请求
- [ ] 新组件自动生成：内容+标题+元信息
- [ ] 连线完成和布局优化

**Day 12-14: 多输入融合机制 (二生三)**
- [ ] 右键创建空组件功能
- [ ] 多输入连线关系建立
- [ ] 空组件状态管理和UI显示
- [ ] 多输入上下文聚合逻辑
- [ ] 融合组件AI处理流程
- [ ] 空组件到内容组件的状态转换

**Week 2 验收标准**:
- ✅ 拖拽连线能正确创建新组件 (一生二)
- ✅ AI生成的组件包含合适的标题和元信息
- ✅ 多输入融合功能正常工作 (二生三)
- ✅ 组件状态正确流转
- ✅ WebSocket实时通信稳定

### Week 3: 版本管理 + 信息管理优化

**Day 15-16: 语义化版本管理**
- [ ] 组件版本历史数据模型实现
- [ ] 双击优化功能：优化对话框设计
- [ ] 变更原因、变更类型记录机制
- [ ] 版本历史展示界面
- [ ] 版本diff对比功能
- [ ] 安全回滚功能实现

**Day 17-18: 画布信息管理系统**
- [ ] 显示模式控制器实现
- [ ] 组件搜索功能：搜索标题和内容
- [ ] 筛选功能：按重要性、类型、评分筛选
- [ ] 画布导航：缩略图和快速定位
- [ ] 专注模式：高亮相关组件
- [ ] 画布状态持久化

**Day 19-21: 用户体验优化**
- [ ] 组件交互动效优化
- [ ] 加载状态和错误处理
- [ ] 快捷键支持
- [ ] 响应式设计适配
- [ ] 性能优化：大量组件场景测试
- [ ] 用户引导和帮助文档

**Week 3 验收标准**:
- ✅ 版本管理功能完整可用
- ✅ 信息管理和导航体验良好
- ✅ 大量组件时性能表现良好
- ✅ 用户体验流畅直观

### Week 4: 测试部署上线 + 功能完善

**Day 22-23: 全面测试**
- [ ] 单元测试编写 (>80%覆盖率)
- [ ] 集成测试：完整用户流程测试
- [ ] 性能测试：100+组件场景压力测试
- [ ] 兼容性测试：多浏览器多设备
- [ ] AI生成质量测试和优化
- [ ] 错误边界和异常处理测试

**Day 24-25: 部署准备**
- [ ] 生产环境配置和优化
- [ ] Docker容器化部署
- [ ] 监控告警系统设置
- [ ] 数据备份和恢复方案
- [ ] 安全配置和性能调优
- [ ] 日志收集和分析系统

**Day 26-28: 发布上线**
- [ ] Beta版本发布和内测
- [ ] 用户反馈收集和分析
- [ ] 关键问题修复和优化
- [ ] 正式版本发布
- [ ] 用户文档和使用指南
- [ ] 后续迭代计划制定

**Week 4 验收标准**:
- ✅ 系统稳定运行，无关键bug
- ✅ 性能指标达到预期要求
- ✅ 用户反馈积极，核心功能满足需求
- ✅ 部署流程标准化，监控完善

## 💰 资源投入估算

### 人力资源配置
```yaml
团队规模: 3-4人
项目周期: 4周 (160工时)

角色分配:
  前端开发 (1人): 
    - React Flow画布开发
    - 智能组件系统
    - 用户界面和交互
    工时占比: 40% (64工时)

  后端开发 (1人):
    - API服务开发  
    - LLM服务集成
    - 数据库设计
    - 消息队列架构
    工时占比: 35% (56工时)

  全栈开发 (1人):
    - 前后端联调
    - 版本管理系统
    - 部署运维
    - 测试和优化
    工时占比: 25% (40工时)

  产品/设计 (0.5人):
    - 交互设计优化
    - 用户体验测试
    - 产品功能验证
    工时占比: 根据需要调整
```

### 技术成本
```yaml
开发工具: 免费开源
云服务 (MVP阶段):
  - 服务器: $50/月 (2核4G，支持AI处理)
  - RabbitMQ: $25/月 (CloudAMQP标准版)
  - PostgreSQL: $20/月 (托管数据库)
  - Redis: $15/月 (缓存服务)
  - CDN: $10/月
  
AI API费用:
  - OpenAI GPT-4: $0.03/1K tokens
  - 预估月用量: $200-400 (包含元信息生成)
  
总月度成本: ~$320-520
```

### 风险评估
```yaml
技术风险 (低-中等):
  - React Flow学习曲线和迁移风险 (可控)
  - AI生成质量稳定性 (通过测试优化)
  - 大规模组件性能挑战 (React Flow内置解决方案)

时间风险 (低):
  - 功能范围清晰，技术方案成熟
  - 可降级实现的备选方案
  - 分阶段开发，风险可控

资源风险 (低):
  - 团队技能匹配度高
  - 开源技术栈降低成本
  - 云服务弹性扩展
```

## ✅ MVP验收标准

### 核心功能验收
```yaml
画布基础能力:
  - ✅ 支持无限滚动和缩放 (10%-500%)
  - ✅ 流畅交互性能 (延迟<16ms, 60fps)
  - ✅ 支持200+组件无性能问题
  - ✅ 响应式适配 (1200px-4K分辨率)

智能组件系统:
  - ✅ 组件标题、重要性、置信度正确显示
  - ✅ 三种显示模式切换流畅
  - ✅ 基于重要性的视觉层次清晰
  - ✅ 组件编辑和优化功能正常

AI协作机制:
  - ✅ 连线创建组件成功率>95%
  - ✅ 多输入融合功能正常
  - ✅ AI生成内容质量达标 (专家评分>4/5)
  - ✅ 响应时间<5秒

版本管理:
  - ✅ 变更原因记录完整
  - ✅ 版本历史可追溯
  - ✅ 回滚功能安全可靠
  - ✅ diff对比清晰准确

信息管理:
  - ✅ 搜索和筛选功能有效
  - ✅ 大量组件时导航便捷
  - ✅ 专注模式提升使用体验
```

### 性能指标
```yaml
响应性能:
  - 画布交互延迟: <16ms (60fps)
  - AI生成响应: <5秒
  - 页面加载时间: <3秒
  - 组件渲染延迟: <100ms

稳定性能:
  - 系统可用性: >99%
  - 错误率: <1%
  - 数据丢失率: 0%
  - 内存泄漏: 无明显泄漏

扩展性能:
  - 支持组件数量: 500+ (流畅)
  - 并发用户支持: 50+ (MVP阶段)
  - 存储扩展性: 100GB+ (项目数据)
```

### 用户体验指标
```yaml
易用性:
  - 新用户学习时间: <10分钟
  - 核心功能完成率: >85%
  - 错误操作恢复: <30秒

满意度:
  - 整体满意度: >4.2/5
  - 功能完整性: >4.0/5
  - 性能体验: >4.3/5
  - 创新性认知: >4.5/5

效率提升:
  - 思维整理效率: 提升50%+
  - 内容生成效率: 提升60%+
  - 决策分析效率: 提升40%+
```

## 🎯 开发优先级

### P0 (必须实现 - 核心价值)
1. React Flow画布引擎和基础交互
2. 智能组件系统 (标题、重要性、置信度)
3. AI处理机制和连线扩展
4. 多层次信息展示
5. 语义化版本管理

### P1 (重要优化 - 体验提升)
1. 搜索和筛选功能
2. 画布导航和专注模式
3. 性能优化和错误处理
4. 用户界面细节打磨

### P2 (如果有时间 - 锦上添花)
1. 高级快捷键支持
2. 批量操作功能
3. 导出和分享功能
4. 个性化设置和主题

## MVP核心价值验证

### 解决的核心问题
1. **思维整理混乱**：通过结构化画布和智能组件解决
2. **信息过载困扰**：通过多层次展示和重要性管理解决
3. **创意扩展瓶颈**：通过AI连线扩展机制解决
4. **决策追溯困难**：通过语义化版本管理解决
5. **协作效率低下**：通过实时AI协作解决

### 差异化优势
- 🎯 **智能语义化**：不仅管理内容，更理解内容含义
- 🚀 **高性能画布**：支持大规模复杂思维网络
- 🧠 **认知友好**：版本管理符合人类思维习惯
- ⚡ **实时AI协作**：从被动工具到主动伙伴
- 🌊 **无限扩展性**：从简单想法到复杂方案的完整路径

### 商业价值验证
```yaml
目标用户价值:
  - 节约思维整理时间: 60%+
  - 提升决策质量: 40%+
  - 减少遗漏风险: 70%+
  - 加速方案迭代: 50%+

市场差异化:
  - 相比传统思维导图: 增加AI智能和语义理解
  - 相比纯AI工具: 增加结构化管理和版本控制
  - 相比协作平台: 增加个人深度思考支持

用户付费意愿:
  - 个人用户: ¥99-199/月
  - 团队用户: ¥499-999/月
  - 企业用户: ¥1999+/月
```

这个V2.0开发计划在保持原有极简创造理念的基础上，通过组件语义化、信息层次管理、智能版本控制和现代化技术栈，打造了一个真正适合大规模思维协作的智能平台。整个计划注重实用性和可执行性，为后续的产品迭代和商业化奠定了坚实基础。